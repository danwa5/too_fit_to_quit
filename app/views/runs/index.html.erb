<div class="page-header">
  <div class="pod">
    <h2 class="is-2">Runs</h2>
  </div>
</div>

<div class="columns is-multiline">
  <div class="column is-one-quarter">
    <div class="pod">
      <%= form_tag(runs_path, method: :get, class: 'run-search-form') do |f| %>
        <div class="form-group">
          <%= label_tag :date, nil, class: " col-xs-12 control-label" %>
          <div class="col-xs-6 col-sm-6">
            <%= text_field_tag :start_date, (params[:start_date] || Date.today - 90), { class: 'form-control', placeholder: 'From' } %>
          </div>
          <div class="col-xs-6 col-sm-6">
            <%= text_field_tag :end_date, params[:end_date], { class: 'form-control', placeholder: 'To' } %>
          </div>
        </div>
        <div class="form-group">
          <%= label_tag :distance, "Distance (miles)", class: "col-xs-12 control-label" %>
          <div class="col-xs-6 col-sm-6">
            <%= text_field_tag :distance_min, params[:distance_min], { class: 'form-control', placeholder: 'min' } %>
          </div>
          <div class="col-xs-6 col-sm-6">
            <%= text_field_tag :distance_max, params[:distance_max], { class: 'form-control', placeholder: 'max' } %>
          </div>
        </div>
        <div class="form-group">
          <%= label_tag :duration, "Duration (minutes)", class: "col-xs-12 control-label" %>
          <div class="col-xs-6 col-sm-6">
            <%= text_field_tag :duration_min, params[:duration_min], { class: 'form-control', placeholder: 'min' } %>
          </div>
          <div class="col-xs-6 col-sm-6">
            <%= text_field_tag :duration_max, params[:duration_max], { class: 'form-control', placeholder: 'max' } %>
          </div>
        </div>
        <div class="form-group">
          <%= label_tag :steps, nil, class: "col-xs-12 control-label" %>
          <div class="col-xs-6 col-sm-6">
            <%= text_field_tag :steps_min, params[:steps_min], { class: 'form-control', placeholder: 'min' } %>
          </div>
          <div class="col-xs-6 col-sm-6">
            <%= text_field_tag :steps_max, params[:steps_max], { class: 'form-control', placeholder: 'max' } %>
          </div>
        </div>
        <div class="form-group">
          <%= label_tag :location, nil, class: "control-label" %>
          <%= select_tag :location, options_from_collection_for_select(@locations, 'location', 'location', params[:location]), { include_blank: true } %>
        </div>
        <script>
          $(function() {
            $('#location').selectize({ allowEmptyOption: true, sortField: 'text' });
          });
        </script>
        <%= submit_tag 'Search', class: 'btn btn-primary search-button' %>
      <% end %>
    </div>
  </div>
  <div class="column is-three-quarters">
    <div class="pod">
      <div id="chart-monthly-breakdown" class="has-text-centered">
        <h5>Monthly Breakdown <a class="toggle-charts">toggle</a></h5>
      </div>

      <div id="chart-monthly-breakdown-2" class="has-text-centered" style="display: none">
        <h5>Monthly Breakdown <a class="toggle-charts">toggle</a></h5>
      </div>
    </div>
  </div>
</div>

<div class="columns">
  <div class="column">
    <div class="pod">
      <div class="table-responsive">
        <table id="runs-table" class="table table-condensed table-hover">
          <thead>
            <tr>
              <th>Date</th>
              <th>Distance<br>(miles)</th>
              <th>Duration<br>(H:MM:SS)</th>
              <th>Pace<br>(min/mile)</th>
              <th>Steps</th>
              <th>Location</th>
              <th></th>
            </tr>
          </thead>
          <tbody>
          <% @dataset.each do |run| %>
            <tr>
              <td class="runs-date"><%= format_run_time(run.start_time) %></td>
              <td class="runs-distance"><%= format_distance(run.distance) %></td>
              <td class="runs-duration"><%= format_duration(run.duration) %></td>
              <td class="runs-pace"><%= format_pace(run.duration, run.distance) %></td>
              <td class="runs-steps"><%= run.steps %></td>
              <td class="runs-location"><%= run.location %></td>
              <td align="center"><%= link_to 'Details', run_path(run.id) %></td>
            </tr>
          <% end %>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<script>

// Set up data sets
var dataset = <%= raw @monthly_breakdown.to_json %>;

// get all unique years in dataset
var years = d3.keys(dataset[0]).filter(function(key) { return key.startsWith('total_'); });

var dataset_2 = [];
var gridSpace = {};
var today = new Date();
var validDataPoint = false;

years.forEach(function(key, index) {
  var year = key.replace(/total_/, '');
  gridSpace[year] = 0;
  dataset.forEach(function(d, i) {
    // Set flag when encounter first valid data point
    if (index == 0 && d[key] != null) {
      validDataPoint = true;
    }

    // Skip iteration if data point is invalid
    if (validDataPoint == false) {
      return;
    }

    var date = new Date(year,(d.month-1),1);
    // Do not include any future dates
    if (date <= today) {
      dataset_2.push({ date: date, total: d[key] });
      gridSpace[year] += 1;
    }
  });
});

// Decrement 1 for current year because the last data point
// does not have a background grid of its own.
gridSpace[today.getFullYear()] -= 1;

// Total number of grid spaces across the chart
var totalGridSpace = 0;
Object.values(gridSpace).forEach(function(value) {
  totalGridSpace += value;
});

var months = { 1:'Jan', 2:'Feb', 3:'Mar', 4:'Apr', 5:'May', 6:'Jun', 7:'Jul', 8:'Aug', 9:'Sep', 10:'Oct', 11:'Nov', 12:'Dec' };

var colors = ["#8a89a6", "#d0743c", "#98D03C"];

var margin = { top: 20, right: 40, left: 50, bottom: 40 }, width, height, maxTotal;

function renderGridlines(type, scale, numGrids) {
  if (type == 'horizontal') {
    return d3.axisLeft(scale).ticks(numGrids);
  } else {
    return d3.axisBottom(scale).ticks(numGrids);
  }
}


var Chart = (function(window,d3) {

  var data, svg, chartWrapper, xScale, yScale, xAxis, yAxis, yAxisLabel, xGrid, yGrid, legend, line_2015, line_2016, line_2017, maxTotalsByMonth = [];

  init(dataset); //load data, then initialize chart

  function init(dataset) {
    data = dataset;

    // format the data
    data.forEach(function(d) {
      d.month = months[d.month];
      d.total_2015 = +d.total_2015;
      d.total_2016 = +d.total_2016;
      d.total_2017 = +d.total_2017;

      d.totals = years.map(function(name) { return {name: name, total: +d[name]}; });
      maxTotalsByMonth.push(Math.max(d[years[0]], d[years[1]]));
    });

    maxTotal = d3.max(maxTotalsByMonth);

    // initialize scales
    xScale = d3.scaleBand().domain(data.map(function(d) { return d.month; }));
    yScale = d3.scaleLinear().domain([0, d3.max(data, function(d) { return d3.max(d.totals, function(d2) { return d2.total; }); })]);
    color = d3.scaleOrdinal().range(colors);

    // initialize svg and other elements
    svg = d3.select('#chart-monthly-breakdown').append('svg');
    chartWrapper = svg.append('g');
    path_2015 = chartWrapper.append('path').datum(data).classed('line_2015', true);
    path_2016 = chartWrapper.append('path').datum(data).classed('line_2016', true);
    path_2017 = chartWrapper.append('path').datum(data).classed('line_2017', true);
    xAxis = chartWrapper.append('g').classed('x-axis', true);
    yAxis = chartWrapper.append('g').classed('y-axis', true);
    yAxisLabel = chartWrapper.select('.y-axis').append('text');
    xGrid = chartWrapper.append('g').classed('grid x-grid', true);
    yGrid = chartWrapper.append('g').classed('grid y-grid', true);

    // initialize legend
    legend = chartWrapper.selectAll(".legend")
          .data(years.slice())
        .enter().append("g")
          .attr("class", "legend")
          .attr("transform", function(d, i) {
            return "translate(0," + i * 20 + ")";
          });

    legendRect = legend.append("rect");
    legendText = legend.append("text");

    // the path generator for the line chart
    line_2015 = d3.line()
      .x(function(d) { return xScale(d.month) })
      .y(function(d) { return yScale(d.total_2015) });

    line_2016 = d3.line()
      .x(function(d) { return xScale(d.month) })
      .y(function(d) { return yScale(d.total_2016) });

    line_2017 = d3.line()
      .x(function(d) { return xScale(d.month) })
      .y(function(d) { return yScale(d.total_2017) });

    // render the chart
    render();
  }

  function render() {

    // get dimensions based on width of parent div
    var dw = getChartWidth();
    updateDimensions(dw);

    // update x and y scales to new dimensions
    xScale.range([0, width]).padding(1.0);
    yScale.range([height, 0]);

    // update svg elements to new dimensions
    svg.attr('width', width + margin.right + margin.left)
       .attr('height', height + margin.top + margin.bottom);
    chartWrapper.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    // update the both axes
    xAxis.attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(xScale));

    yAxis.call(d3.axisLeft(yScale).ticks(maxTotal));

    // update y-axis label
    yAxisLabel.attr("class", "axis-title")
      .attr("transform", "rotate(-90)")
      .attr("y", -40)
      .attr("x", 0 - (height / 2))
      .attr("dy", ".71em")
      .style("text-anchor", "middle")
      .text("Monthly Total");

    // update x-axis grid lines
    xGrid.attr("transform", "translate(0," + height + ")")
      .transition().call(renderGridlines('vertical', xScale, data.length).tickSize(-height).tickFormat(""));

    // update y-axis grid lines
    yGrid.transition().call(renderGridlines('horizontal', yScale, maxTotal).tickSize(-width).tickFormat(""));

    // update lines
    path_2015.attr('d', line_2015)
        .attr("fill", "none")
        .attr("stroke", colors[0])
        .attr("stroke-width", 1.5);

    path_2016.attr('d', line_2016)
        .attr("fill", "none")
        .attr("stroke", colors[1])
        .attr("stroke-width", 1.5);

    path_2017.attr('d', line_2017)
        .attr("fill", "none")
        .attr("stroke", colors[2])
        .attr("stroke-width", 1.5);

    // update legend
    legendRect.attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

    legendText.attr("x", width - 24)
      .attr("y", 10)
      .attr("dy", ".25em")
      .style("text-anchor", "end")
      .text(function(d) {
        return d.substr(d.length-4);
      });
  }

  return {
    render : render
  }

})(window,d3);


var Chart_2 = (function(window,d3) {

  var data_2, svg_2, chartWrapper_2, xScale_2, yScale_2, xAxis_2, yAxis_2, yAxisLabel_2, xGrid_2, yGrid_2, bkgdA, bkgdB, bkgdC, path_2, line_2;
  var bkgdColors = ["#e2e2e9", "#f5e2d6", "#e9f5d6"];

  init(dataset_2); //load data, then initialize chart

  function init(dataset) {
    data_2 = dataset;

    // initialize scales
    maxTotal = d3.max(data_2, function(d) { return d.total; });
    xScale_2 = d3.scaleTime().domain(d3.extent(data_2, function(d) { return d.date; }));
    yScale_2 = d3.scaleLinear().domain([0, maxTotal]);

    svg_2 = d3.select("#chart-monthly-breakdown-2").append("svg");
    chartWrapper_2 = svg_2.append('g');
    bkgdA = chartWrapper_2.append("rect");
    bkgdB = chartWrapper_2.append("rect");
    bkgdC = chartWrapper_2.append("rect");
    path_2 = chartWrapper_2.append('path').datum(data_2).classed('line_2', true);
    xAxis_2 = chartWrapper_2.append('g').classed('x-axis', true);
    yAxis_2 = chartWrapper_2.append('g').classed('y-axis', true);
    yAxisLabel_2 = chartWrapper_2.select('.y-axis').append('text');
    xGrid_2 = chartWrapper_2.append('g').classed('grid x-grid', true);
    yGrid_2 = chartWrapper_2.append('g').classed('grid y-grid', true);

    // the path generator for the line chart
    line_2 = d3.line()
      .x(function(d) { return xScale_2(d.date) })
      .y(function(d) { return yScale_2(d.total) });

    // render the chart
    render();
  }

  function render() {

    // get dimensions based on width of parent div
    var dw = getChartWidth();
    updateDimensions(dw);

    // update x and y scales to new dimensions
    xScale_2.range([0, width]);
    yScale_2.rangeRound([height, 0]);

    // update svg elements to new dimensions
    svg_2.attr('width', width + margin.right + margin.left)
        .attr('height', height + margin.top + margin.bottom);
    chartWrapper_2.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    // update the both axes
    xAxis_2.attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(xScale_2).tickFormat(d3.timeFormat("%b %Y")));

    yAxis_2.call(d3.axisLeft(yScale_2).ticks(maxTotal));

    // update y-axis label
    yAxisLabel_2.attr("class", "axis-title")
      .attr("transform", "rotate(-90)")
      .attr("y", -40)
      .attr("x", 0 - (height / 2))
      .attr("dy", ".71em")
      .style("text-anchor", "middle")
      .text("Monthly Total");

    // update x-axis grid lines
    xGrid_2.attr("transform", "translate(0," + height + ")")
      .transition().call(renderGridlines('vertical', xScale_2, data_2.length).tickSize(-height).tickFormat(""));

    // update y-axis grid lines
    yGrid_2.transition().call(renderGridlines('horizontal', yScale_2, maxTotal).tickSize(-width).tickFormat(""));

    // update backgrounds
    bkgdA.attr("x",0)
      .attr("y",0)
      .attr("width", (width * (gridSpace[today.getFullYear()-2]/totalGridSpace)))
      .attr("height",height)
      .style("fill", bkgdColors[0]);

    bkgdB.attr("x",(width * (gridSpace[today.getFullYear()-2]/totalGridSpace)))
      .attr("y",0)
      .attr("width", (width * (gridSpace[today.getFullYear()-1]/totalGridSpace)))
      .attr("height",height)
      .style("fill", bkgdColors[1]);

    bkgdC.attr("x",(width * ((gridSpace[today.getFullYear()-2]/totalGridSpace) + (gridSpace[today.getFullYear()-1]/totalGridSpace))))
      .attr("y",0)
      .attr("width", (width * (gridSpace[today.getFullYear()]/totalGridSpace)))
      .attr("height",height)
      .style("fill", bkgdColors[2]);

    // update lines
    path_2.attr('d', line_2)
        .attr("fill", "none")
        .attr("stroke", colors[0])
        .attr("stroke-width", 1.5);
  }

  return {
    render : render
  }

})(window,d3);


function updateDimensions(chartParentWidth) {
  margin.left  = chartParentWidth < 600 ? 40 : 50;
  margin.right = chartParentWidth < 600 ? 10 : 40;
  aspectRatio  = chartParentWidth < 500 ? 0.55 : 0.47;
  width = chartParentWidth - margin.left - margin.right;
  height = aspectRatio * width;
}

function getChartWidth() {
  if ($('#chart-monthly-breakdown').is(':visible')) {
    return document.getElementById("chart-monthly-breakdown").offsetWidth;
  } else if ($('#chart-monthly-breakdown-2').is(':visible')) {
    return document.getElementById("chart-monthly-breakdown-2").offsetWidth;
  }
}


window.addEventListener('resize', Chart.render);
window.addEventListener('resize', Chart_2.render);

$('.toggle-charts').click(function() {
  if ($('#chart-monthly-breakdown').is(':visible')) {
    $('#chart-monthly-breakdown').hide();
    $('#chart-monthly-breakdown-2').show();
  } else {
    $('#chart-monthly-breakdown').show();
    $('#chart-monthly-breakdown-2').hide();
  }
});

</script>
